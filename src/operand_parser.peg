%value "Operand*"
%auxil "pcc_string_input_t*"
%header {
#include "loader.h"
#include "operand_parser_types.h"
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdint.h>
#include <stdio.h>

/* --- DEBUGGING HELPERS --- */
static const char* sprint_operand(const Operand* op) {
    static char debug_buffer[512];
    if (!op) return "(null)";
    char temp[400];
    char index_str[100] = "";
    char base_disp_str[100] = "";
    char outer_disp_str[100] = "";
    if (op->index_reg_num != -1) {
        snprintf(index_str, sizeof(index_str), ", %c%d.%c*%d", op->index_is_an ? 'A' : 'D', op->index_reg_num, op->index_size, 1 << op->scale);
    }
    if (op->label) {
        snprintf(base_disp_str, sizeof(base_disp_str), "%s", op->label);
    } else if (op->base_displacement != 0 || op->mode == ARI_INDEX_BASE_DISP || op->mode == MEMORY_INDIRECT_POST_INDEXED || op->mode == ARI_DISPLACEMENT || op->mode == PC_RELATIVE_DISPLACEMENT) {
         snprintf(base_disp_str, sizeof(base_disp_str), "%d", op->base_displacement);
    }
    if (op->outer_displacement != 0) {
        snprintf(outer_disp_str, sizeof(outer_disp_str), ", %d", op->outer_displacement);
    }
    switch (op->mode) {
        case DATA_REGISTER_DIRECT: snprintf(temp, sizeof(temp), "Dn (D%d)", op->reg_num); break;
        case ADDRESS_REGISTER_DIRECT: snprintf(temp, sizeof(temp), "An (A%d)", op->reg_num); break;
        case IMMEDIATE: if (op->label) snprintf(temp, sizeof(temp), "Immediate (#%s)", op->label); else snprintf(temp, sizeof(temp), "Immediate (#$%X)", op->value); break;
        case ADDRESS_REGISTER_INDIRECT: snprintf(temp, sizeof(temp), "AR Indirect ((A%d))", op->reg_num); break;
        case ARI_POST_INCREMENT: snprintf(temp, sizeof(temp), "AR Post-Inc ((A%d)+)", op->reg_num); break;
        case ARI_PRE_DECREMENT: snprintf(temp, sizeof(temp), "AR Pre-Dec (-(A%d))", op->reg_num); break;
        case ARI_DISPLACEMENT: snprintf(temp, sizeof(temp), "AR Displacement (%s(A%d))", base_disp_str, op->reg_num); break;
        case ABSOLUTE_SHORT: snprintf(temp, sizeof(temp), "Absolute Short ($%X)", op->value); break;
        case ABSOLUTE_LONG: snprintf(temp, sizeof(temp), "Absolute Long ($%X)", op->value); break;
        case PC_RELATIVE_DISPLACEMENT: snprintf(temp, sizeof(temp), "PC Displacement (%s(PC))", base_disp_str); break;
        case ARI_INDEX_8_BIT_DISP: snprintf(temp, sizeof(temp), "AR Index d8 (%s(A%d%s))", base_disp_str, op->reg_num, index_str); break;
        case PC_RELATIVE_INDEX_8_BIT: snprintf(temp, sizeof(temp), "PC Index d8 (%s(PC%s))", base_disp_str, index_str); break;
        case ARI_INDEX_BASE_DISP: snprintf(temp, sizeof(temp), "AR Index bd (%s,A%d%s)", base_disp_str, op->reg_num, index_str); break;
        case PC_INDEX_BASE_DISP: snprintf(temp, sizeof(temp), "PC Index bd (%s,PC%s)", base_disp_str, index_str); break;
        case MEMORY_INDIRECT_POST_INDEXED: snprintf(temp, sizeof(temp), "Mem Post-Indexed ([%s,A%d]%s%s)", base_disp_str, op->reg_num, index_str, outer_disp_str); break;
        case MEMORY_INDIRECT_PRE_INDEXED: snprintf(temp, sizeof(temp), "Mem Pre-Indexed ([%s,A%d%s]%s)", base_disp_str, op->reg_num, index_str, outer_disp_str); break;
        case PC_MEM_INDIRECT_POST_INDEXED: snprintf(temp, sizeof(temp), "PC Mem Post-Indexed ([%s,PC]%s%s)", base_disp_str, index_str, outer_disp_str); break;
        case PC_MEM_INDIRECT_PRE_INDEXED: snprintf(temp, sizeof(temp), "PC Mem Pre-Indexed ([%s,PC%s]%s)", base_disp_str, index_str, outer_disp_str); break;
        default: snprintf(temp, sizeof(temp), "Unknown/Partial"); break;
    }
    snprintf(debug_buffer, sizeof(debug_buffer), "{ mode:%d, content:[%s] }", op->mode, temp);
    return debug_buffer;
}

#ifdef DEBUG_PARSER
#define TRACE(rule) fprintf(stderr, "[PEG_TRACE] -> %s\n", rule)
#define TRACE_SUCCESS(rule, op_ptr) fprintf(stderr, "[PEG_TRACE] <-- %s SUCCESS | %s\n", rule, sprint_operand(op_ptr))
#else
#define TRACE(rule)
#define TRACE_SUCCESS(rule, op_ptr)
#endif
}
%source {
#include "operand_parser_types.h"
static int pcc_custom_getchar(pcc_string_input_t* input) {
    if (input->input[input->position] == '\0') return -1;
    return (unsigned char)input->input[input->position++];
}
#define PCC_GETCHAR(auxil) pcc_custom_getchar(auxil)
static char* pcc_strndup(const char *s, size_t n) {
    char *new_s = (char*)malloc(n + 1);
    if (new_s == NULL) return NULL;
    memcpy(new_s, s, n);
    new_s[n] = '\0';
    return new_s;
}
static Operand* create_operand() {
    Operand* op = (Operand*)calloc(1, sizeof(Operand));
    if (op) {
        op->mode = UNKNOWN_MODE; op->reg_num = -1; op->index_reg_num = -1; op->scale = 0;
    }
    return op;
}
}

# --- Grammar Entry Point ---
root <- {TRACE("root");} WHITESPACE? op:operand WHITESPACE? EOT { $$ = op; TRACE_SUCCESS("root", $$); }

operand <- { TRACE("operand"); } (
    op:Operand_Immediate        { $$ = op; TRACE_SUCCESS("operand (Immediate)", $$); } /
    op:Operand_RegisterDirect   { $$ = op; TRACE_SUCCESS("operand (RegisterDirect)", $$); } /
    op:Operand_Absolute         { $$ = op; TRACE_SUCCESS("operand (Absolute)", $$); } /
    op:Operand_Indirect_Complex { $$ = op; TRACE_SUCCESS("operand (Indirect_Complex)", $$); } /
    op:Operand_Indirect_Simple  { $$ = op; TRACE_SUCCESS("operand (Indirect_Simple)", $$); }
)

# --- Basic Terminal Rules ---
WHITESPACE  <- [ \t]+
EOT         <- !.
COMMA       <- WHITESPACE? ',' WHITESPACE?
LPAREN      <- '(' WHITESPACE?
RPAREN      <- WHITESPACE? ')'
LBRACKET    <- '[' WHITESPACE?
RBRACKET    <- WHITESPACE? ']'

# --- Number and Identifier Parsing Rules ---
Identifier <- {TRACE("Identifier");} <[a-zA-Z_][a-zA-Z0-9_]*> { $$ = create_operand(); const pcc_capture_t *cap = pcc_in->data.leaf.capts.p[0]; $$->label = pcc_strndup(pcc_ctx->buffer.p + cap->range.start, cap->range.end - cap->range.start); TRACE_SUCCESS("Identifier", $$); }
HexNumber  <- {TRACE("HexNumber");} '$' <[0-9a-fA-F]+> { $$ = create_operand(); const pcc_capture_t *cap = pcc_in->data.leaf.capts.p[0]; char* s = pcc_strndup(pcc_ctx->buffer.p + cap->range.start, cap->range.end - cap->range.start); $$->value = strtoul(s, NULL, 16); free(s); TRACE_SUCCESS("HexNumber", $$); }
NegativeDec <- '-' <[0-9]+> { $$ = create_operand(); const pcc_capture_t *cap = pcc_in->data.leaf.capts.p[0]; char* s = pcc_strndup(pcc_ctx->buffer.p + cap->range.start, cap->range.end - cap->range.start); $$->value = -strtol(s, NULL, 10); free(s); }
PositiveDec <- <[0-9]+> { $$ = create_operand(); const pcc_capture_t *cap = pcc_in->data.leaf.capts.p[0]; char* s = pcc_strndup(pcc_ctx->buffer.p + cap->range.start, cap->range.end - cap->range.start); $$->value = strtol(s, NULL, 10); free(s); }
DecNumber   <- {TRACE("DecNumber");} ( op:NegativeDec { $$ = op; TRACE_SUCCESS("DecNumber (Negative)", $$); } / op:PositiveDec { $$ = op; TRACE_SUCCESS("DecNumber (Positive)", $$); } )
Number      <- {TRACE("Number");} ( op:HexNumber { $$ = op; TRACE_SUCCESS("Number (Hex)", $$); } / op:DecNumber { $$ = op; TRACE_SUCCESS("Number (Dec)", $$); } )

# --- MODIFIED: Rules for label-. expressions ---
PCRelativeLabel <- {TRACE("PCRelativeLabel");} <[a-zA-Z_][a-zA-Z0-9_]*> '-' '.' {
    $$ = create_operand();
    $$->is_pc_relative_label = true;
    const pcc_capture_t *cap = pcc_in->data.leaf.capts.p[0];
    $$->label = pcc_strndup(pcc_ctx->buffer.p + cap->range.start, cap->range.end - cap->range.start);
    TRACE_SUCCESS("PCRelativeLabel", $$);
}

# --- Component Rules for Building Addressing Modes ---
SizeCapture     <- <[wWlL]> { $$ = create_operand(); $$->value = toupper(pcc_ctx->buffer.p[pcc_in->data.leaf.capts.p[0]->range.start]); }
ScaleCapture    <- <[1248]> { $$ = create_operand(); char s = pcc_ctx->buffer.p[pcc_in->data.leaf.capts.p[0]->range.start]; if(s=='2')$$->value=1; else if(s=='4')$$->value=2; else if(s=='8')$$->value=3; else $$->value=0; }
SizeSuffix      <- {TRACE("SizeSuffix");} '.' op:SizeCapture { $$ = op; TRACE_SUCCESS("SizeSuffix", $$); }
Scale           <- {TRACE("Scale");} '*' op:ScaleCapture { $$ = op; TRACE_SUCCESS("Scale", $$); }

Displacement    <- {TRACE("Displacement");} (
    op:Number          { $$ = op; TRACE_SUCCESS("Displacement (Number)", $$); } /
    op:PCRelativeLabel { $$ = op; TRACE_SUCCESS("Displacement (PCRelativeLabel)", $$); } /
    op:Identifier      { $$ = op; TRACE_SUCCESS("Displacement (Identifier)", $$); }
)

AnRegSpecifier  <- 'A' <[0-7]> { $$ = create_operand(); $$->reg_num = pcc_ctx->buffer.p[pcc_in->data.leaf.capts.p[0]->range.start] - '0'; }
DnRegSpecifier  <- 'D' <[0-7]> { $$ = create_operand(); $$->reg_num = pcc_ctx->buffer.p[pcc_in->data.leaf.capts.p[0]->range.start] - '0'; }
PCRegSpecifier  <- 'PC' { $$ = create_operand(); $$->reg_num = -1; }
BaseRegister    <- {TRACE("BaseRegister");} ( op:AnRegSpecifier { $$ = op; TRACE_SUCCESS("BaseRegister (An)", $$); } / op:PCRegSpecifier { $$ = op; TRACE_SUCCESS("BaseRegister (PC)", $$); } )
IndexRegSpecifier <- {TRACE("IndexRegSpecifier");} ( op:AnRegSpecifier { $$ = op; $$->index_is_an = true; } / op:DnRegSpecifier { $$ = op; $$->index_is_an = false; } )
IndexRegister   <- {TRACE("IndexRegister");} reg_part:IndexRegSpecifier sz:SizeSuffix? sc:Scale? { $$ = reg_part; if (sz) { $$->index_size = sz->value; free(sz); } else { $$->index_size = 'W'; } if (sc) { $$->scale = sc->value; free(sc); } TRACE_SUCCESS("IndexRegister", $$); }

# --- Rules for Final Operand Forms ---
Operand_Immediate       <- {TRACE("Operand_Immediate");} '#' ( op:Number { $$ = op; $$->mode = IMMEDIATE; } / op:Identifier { $$ = op; $$->mode = IMMEDIATE; } )
AbsoluteValue           <- ( op:Number { $$ = op; } / op:Identifier { $$ = op; } )
Absolute_Form           <- {TRACE("Absolute_Form");} ( op:LPAREN val:AbsoluteValue RPAREN { $$ = val; TRACE_SUCCESS("Absolute_Form (Parenthesized)", $$); } / op:AbsoluteValue { $$ = op; TRACE_SUCCESS("Absolute_Form (Bare)", $$); } )
Operand_Absolute        <- {TRACE("Operand_Absolute");} val:Absolute_Form sz:SizeSuffix? { $$ = val; if (sz && sz->value == 'L') $$->mode = ABSOLUTE_LONG; else $$->mode = ABSOLUTE_SHORT; if (sz) free(sz); }
Operand_RegisterDirect  <- {TRACE("Operand_RegisterDirect");} ( op:DnRegSpecifier { $$ = op; $$->mode = DATA_REGISTER_DIRECT; } / op:AnRegSpecifier { $$ = op; $$->mode = ADDRESS_REGISTER_DIRECT; } )

# --- Simple Indirect Forms ---
ARI_Rule                <- LPAREN reg:AnRegSpecifier RPAREN { $$ = reg; $$->mode = ADDRESS_REGISTER_INDIRECT; }
ARI_PostIncrement_Rule  <- LPAREN reg:AnRegSpecifier RPAREN '+' { $$ = reg; $$->mode = ARI_POST_INCREMENT; }
ARI_PreDecrement_Rule   <- '-' LPAREN reg:AnRegSpecifier RPAREN { $$ = reg; $$->mode = ARI_PRE_DECREMENT; }
Displacement_Rule       <- disp:Displacement LPAREN base:BaseRegister RPAREN { $$ = base; if ($$->reg_num == -1) $$->mode = PC_RELATIVE_DISPLACEMENT; else $$->mode = ARI_DISPLACEMENT; if (disp->label) $$->label = disp->label; else $$->base_displacement = disp->value; free(disp); }
Operand_Indirect_Simple <- {TRACE("Operand_Indirect_Simple");} ( op:ARI_PreDecrement_Rule { $$ = op; } / op:ARI_PostIncrement_Rule { $$ = op; } / op:Displacement_Rule { $$ = op; } / op:ARI_Rule { $$ = op; } )

# --- Complex 68020+ Indirect Forms ---
Inner_PreIndexed        <- {TRACE("Inner_PreIndexed");} LBRACKET bd:Displacement? COMMA base:BaseRegister COMMA idx:IndexRegister RBRACKET { $$ = base; $$->index_reg_num = idx->reg_num; $$->index_is_an = idx->index_is_an; $$->index_size = idx->index_size; $$->scale = idx->scale; free(idx); if(bd) { if(bd->label) $$->label = bd->label; else $$->base_displacement = bd->value; free(bd); } TRACE_SUCCESS("Inner_PreIndexed", $$); }
Inner_PostIndexed       <- {TRACE("Inner_PostIndexed");} LBRACKET bd:Displacement? COMMA base:BaseRegister RBRACKET { $$ = base; if(bd) { if(bd->label) $$->label = bd->label; else $$->base_displacement = bd->value; free(bd); } TRACE_SUCCESS("Inner_PostIndexed", $$); }
MemIndirect_Post_Rule   <- LPAREN inner:Inner_PostIndexed COMMA idx:IndexRegister (COMMA od:Displacement)? RPAREN { $$ = inner; $$->index_reg_num = idx->reg_num; $$->index_is_an = idx->index_is_an; $$->index_size = idx->index_size; $$->scale = idx->scale; free(idx); if ($$->reg_num == -1) $$->mode = PC_MEM_INDIRECT_POST_INDEXED; else $$->mode = MEMORY_INDIRECT_POST_INDEXED; if (od) { if (od->label) { /* Complicated labels not handled */ } else { $$->outer_displacement = od->value; } free(od); } }
MemIndirect_Pre_Rule    <- LPAREN inner:Inner_PreIndexed (COMMA od:Displacement)? RPAREN { $$ = inner; if ($$->reg_num == -1) $$->mode = PC_MEM_INDIRECT_PRE_INDEXED; else $$->mode = MEMORY_INDIRECT_PRE_INDEXED; if (od) { if (od->label) { /* Complicated labels not handled */ } else { $$->outer_displacement = od->value; } free(od); } }
Index_BaseDisp_Rule     <- LPAREN bd:Displacement COMMA base:BaseRegister COMMA idx:IndexRegister RPAREN { $$ = base; $$->index_reg_num = idx->reg_num; $$->index_is_an = idx->index_is_an; $$->index_size = idx->index_size; $$->scale = idx->scale; free(idx); if ($$->reg_num == -1) $$->mode = PC_INDEX_BASE_DISP; else $$->mode = ARI_INDEX_BASE_DISP; if (bd->label) $$->label = bd->label; else $$->base_displacement = bd->value; free(bd); }
Index_8BitDisp_Rule     <- disp:Displacement LPAREN base:BaseRegister COMMA idx:IndexRegister RPAREN { $$ = base; $$->index_reg_num = idx->reg_num; $$->index_is_an = idx->index_is_an; $$->index_size = idx->index_size; $$->scale = idx->scale; free(idx); if ($$->reg_num == -1) $$->mode = PC_RELATIVE_INDEX_8_BIT; else $$->mode = ARI_INDEX_8_BIT_DISP; if (disp->label) $$->label = disp->label; else $$->base_displacement = disp->value; free(disp); }
Operand_Indirect_Complex <- {TRACE("Operand_Indirect_Complex");} ( op:MemIndirect_Post_Rule { $$ = op; } / op:MemIndirect_Pre_Rule { $$ = op; } / op:Index_BaseDisp_Rule { $$ = op; } / op:Index_8BitDisp_Rule { $$ = op; } )