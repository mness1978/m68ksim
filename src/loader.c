#define _DEFAULT_SOURCE
#include "loader.h"
#include "memory.h"
#include "disassembler.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

// You must include the header generated by packcc
#include "operand_parser.h"

#define HASH_TABLE_SIZE 1024

static HashTable* symbol_table = NULL;

// --- Symbol Table and File I/O Functions (mostly unchanged) ---

static unsigned long hash(const char* str) {
    unsigned long hash = 5381;
    int c;
    while ((c = *str++)) hash = ((hash << 5) + hash) + c;
    return hash;
}
HashTable* create_symbol_table(unsigned int size) {
    HashTable* ht = malloc(sizeof(HashTable));
    if (!ht) return NULL;
    ht->size = size;
    ht->table = calloc(size, sizeof(Symbol*));
    if (!ht->table) { free(ht); return NULL; }
    return ht;
}
void destroy_symbol_table(HashTable* ht) {
    if (!ht) return;
    for (unsigned int i = 0; i < ht->size; i++) {
        Symbol* current = ht->table[i];
        while (current) {
            Symbol* next = current->next;
            free(current->name);
            free(current);
            current = next;
        }
    }
    free(ht->table);
    free(ht);
}
void add_symbol(HashTable* ht, const char* name, uint32_t address) {
    if (find_symbol(ht, name)) { return; }
    unsigned long hash_index = hash(name) % ht->size;
    Symbol* new_symbol = malloc(sizeof(Symbol));
    if (!new_symbol) { return; }
    new_symbol->name = strdup(name);
    new_symbol->address = address;
    new_symbol->next = ht->table[hash_index];
    ht->table[hash_index] = new_symbol;
}
Symbol* find_symbol(HashTable* ht, const char* name) {
    unsigned long hash_index = hash(name) % ht->size;
    Symbol* current = ht->table[hash_index];
    while (current) {
        if (strcmp(current->name, name) == 0) return current;
        current = current->next;
    }
    return NULL;
}
char* read_line_dynamically(FILE* f) {
    char* line = NULL;
    size_t size = 0;
    ssize_t len = getline(&line, &size, f);
    if (len == -1) { free(line); return NULL; }
    if (len > 0 && line[len - 1] == '\n') { line[len - 1] = '\0'; }
    return line;
}
char* trim(char* str) {
    if (!str) return str;
    char* end;
    while (isspace((unsigned char)*str)) str++;
    if (*str == 0) return str;
    end = str + strlen(str) - 1;
    while (end > str && isspace((unsigned char)*end)) end--;
    end[1] = '\0';
    return str;
}
void parse_instruction_mnemonic(const char* opcode_str, char* base, char* size) {
    *size = 'W';
    const char* dot = strrchr(opcode_str, '.');
    if (dot && (tolower(dot[1]) == 'b' || tolower(dot[1]) == 'w' || tolower(dot[1]) == 'l')) {
        strncpy(base, opcode_str, dot - opcode_str);
        base[dot - opcode_str] = '\0';
        *size = toupper(dot[1]);
    } else {
        strcpy(base, opcode_str);
    }
}

// --- NEW: Wrapper for the PackCC Parser ---
int parse_operand(const char* str, Operand* operand) {
    if (!str || !operand) return -1;

    char trimmed_str[256];
    strncpy(trimmed_str, str, 255);
    trimmed_str[255] = '\0';
    char* start = trim(trimmed_str);
    if (*start == '\0') return -1;

    // --- THE FIX IS HERE ---
    // 1. Create the struct that our custom getchar expects.
    pcc_string_input_t input_source;
    input_source.input = start;
    input_source.position = 0;

    // 2. Pass a pointer TO THE STRUCT, not to the raw string.
    pcc_context_t* ctx = pcc_create(&input_source);

    Operand* result = NULL;
    if (pcc_parse(ctx, &result) != 1 || result == NULL) {
        pcc_destroy(ctx);
        // fprintf(stderr, "DEBUG: Failed to parse operand: '%s'\n", str); // Optional debug line
        return -1;
    }

    *operand = *result;
    free(result); // The parser allocates, we copy, then we free.
    pcc_destroy(ctx);
    return 0;
}


// --- NEW: Rewritten Sizing Logic ---

// Calculates the size of all extension words and displacements for a given operand
int get_operand_extension_size(Operand* op) {
    if (!op) return 0;

    switch (op->mode) {
        case IMMEDIATE: return (op->label || op->value > 0xFFFF) ? 4 : 2;
        case ABSOLUTE_SHORT: return 2;
        case ABSOLUTE_LONG: return 4;
        case ARI_DISPLACEMENT: return 2;
        case PC_RELATIVE_DISPLACEMENT: return 2;
        case ARI_INDEX_8_BIT_DISP: return 2;
        case PC_RELATIVE_INDEX_8_BIT: return 2;

        case ARI_INDEX_BASE_DISP:
        case PC_INDEX_BASE_DISP:
        case MEMORY_INDIRECT_POST_INDEXED:
        case MEMORY_INDIRECT_PRE_INDEXED:
        case PC_MEM_INDIRECT_POST_INDEXED:
        case PC_MEM_INDIRECT_PRE_INDEXED:
        {
            int size = 2; // For the extension word
            
            // --- THIS IS THE FIX ---
            // Determine and SET the displacement sizes on the operand struct
            if (op->label || op->base_displacement > 32767 || op->base_displacement < -32768) {
                op->base_disp_size = 4;
            } else if (op->base_displacement != 0) {
                op->base_disp_size = 2;
            } else {
                op->base_disp_size = 0; // Or 1 for null, let's stick to 0 for simplicity
            }

            if (op->outer_displacement > 32767 || op->outer_displacement < -32768) {
                op->outer_disp_size = 4;
            } else if (op->outer_displacement != 0) {
                op->outer_disp_size = 2;
            } else {
                op->outer_disp_size = 0;
            }
            // --- END FIX ---

            size += op->base_disp_size;
            size += op->outer_disp_size;
            return size;
        }

        default: return 0;
    }
}

// Calculates the total size of an instruction including opcode and all operands
int get_instruction_size(const char* opcode_str, const char* operands_str) {
    char base_mnemonic[10];
    char size_suffix;
    parse_instruction_mnemonic(opcode_str, base_mnemonic, &size_suffix);

    // Instructions with no operands or fixed size
    if (strcasecmp(base_mnemonic, "NOP") == 0) return 2;
    if (strcasecmp(base_mnemonic, "RTS") == 0) return 2;
    if (strncasecmp(base_mnemonic, "B", 1) == 0 && strlen(base_mnemonic) > 1) {
         if (strcasecmp(base_mnemonic, "BTST") != 0 && strcasecmp(base_mnemonic, "BCHG") != 0 &&
             strcasecmp(base_mnemonic, "BCLR") != 0 && strcasecmp(base_mnemonic, "BSET") != 0) {
            return 2; // All branch instructions are 2 bytes (short branch)
        }
    }
    
    int total_size = 2; // Base opcode size
    if (!operands_str) return total_size;

    char temp_operands_str[256];
    strncpy(temp_operands_str, operands_str, 255);
    temp_operands_str[255] = '\0';
    
    char* src_str = temp_operands_str;
    char* dest_str = NULL;

    char* comma = strchr(src_str, ',');
    if (comma) {
        *comma = '\0';
        dest_str = comma + 1;
    }

    Operand src_op = {0}, dest_op = {0};
    if (src_str && parse_operand(src_str, &src_op) == 0) {
        if (src_op.mode == IMMEDIATE && size_suffix == 'L') {
             total_size += 4; // Special case for ADDI.L etc.
        } else if (src_op.mode == IMMEDIATE) {
             total_size += 2;
        } else {
            total_size += get_operand_extension_size(&src_op);
        }
        if (src_op.label) free(src_op.label);
    }
    if (dest_str && parse_operand(dest_str, &dest_op) == 0) {
        total_size += get_operand_extension_size(&dest_op);
        if (dest_op.label) free(dest_op.label);
    }
    
    return total_size;
}

// --- NEW: Rewritten Assembler Logic (Second Pass) ---

// Encodes an operand into the standard 6-bit EA field (mode and register)
uint8_t encode_ea(Operand* op) {
    uint8_t mode = 0;
    uint8_t reg = 0;

    switch (op->mode) {
        case DATA_REGISTER_DIRECT:      mode = 0b000; reg = op->reg_num; break;
        case ADDRESS_REGISTER_DIRECT:   mode = 0b001; reg = op->reg_num; break;
        case ADDRESS_REGISTER_INDIRECT: mode = 0b010; reg = op->reg_num; break;
        case ARI_POST_INCREMENT:        mode = 0b011; reg = op->reg_num; break;
        case ARI_PRE_DECREMENT:         mode = 0b100; reg = op->reg_num; break;
        case ARI_DISPLACEMENT:          mode = 0b101; reg = op->reg_num; break;
        case ARI_INDEX_8_BIT_DISP:      mode = 0b110; reg = op->reg_num; break;
        case ABSOLUTE_SHORT:            mode = 0b111; reg = 0b000; break;
        case ABSOLUTE_LONG:             mode = 0b111; reg = 0b001; break;
        case PC_RELATIVE_DISPLACEMENT:  mode = 0b111; reg = 0b010; break;
        case PC_RELATIVE_INDEX_8_BIT:   mode = 0b111; reg = 0b011; break;
        case IMMEDIATE:                 mode = 0b111; reg = 0b100; break;

        // All complex 68020+ modes are variants of (An,idx) or (PC,idx)
        case ARI_INDEX_BASE_DISP:
        case MEMORY_INDIRECT_POST_INDEXED:
        case MEMORY_INDIRECT_PRE_INDEXED:
            mode = 0b110; reg = op->reg_num; break;

        case PC_INDEX_BASE_DISP:
        case PC_MEM_INDIRECT_POST_INDEXED:
        case PC_MEM_INDIRECT_PRE_INDEXED:
            mode = 0b111; reg = 0b011; break;
        default: break;
    }
    return (mode << 3) | reg;
}

// Builds and returns the 16-bit full format extension word for 68020+ modes
uint16_t build_full_format_extension(Operand* op) {
    uint16_t ext = 0;
    ext |= (op->index_is_an ? 1 : 0) << 15;
    ext |= (op->index_reg_num & 7) << 12;
    ext |= (op->index_size == 'L' ? 1 : 0) << 11;
    ext |= (op->scale & 3) << 9;
    ext |= 1 << 8; // This bit MUST be 1 for full format

    // Base Displacement Size encoding
    if (op->base_disp_size == 2) ext |= 0b10 << 4;
    else if (op->base_disp_size == 4) ext |= 0b11 << 4;
    else ext |= 0b01 << 4; // Null displacement

    // Index/Indirect Selection (I/IS) field
    uint8_t iis = 0;
    switch (op->mode) {
        case ARI_INDEX_BASE_DISP:
        case PC_INDEX_BASE_DISP:
            iis = 0b000; // No indirection
            break;

        case MEMORY_INDIRECT_PRE_INDEXED:
        case PC_MEM_INDIRECT_PRE_INDEXED:
            if (op->outer_disp_size == 4) iis = 0b011;      // Pre-indexed, Long OD
            else if (op->outer_disp_size == 2) iis = 0b010; // Pre-indexed, Word OD
            else iis = 0b001;                               // Pre-indexed, No OD
            break;

        case MEMORY_INDIRECT_POST_INDEXED:
        case PC_MEM_INDIRECT_POST_INDEXED:
            if (op->outer_disp_size == 4) iis = 0b111;      // Post-indexed, Long OD
            else if (op->outer_disp_size == 2) iis = 0b110; // Post-indexed, Word OD
            else iis = 0b101;                               // Post-indexed, No OD
            break;

        default: break;
    }
    ext |= iis;

    return ext;
}

// Writes all necessary extension words and displacements for an operand
void write_operand_extensions(uint32_t* address, Operand* op, char size_suffix, uint32_t current_pc) {
    if (!op) return;

    // Handle label resolution first
    if (op->label) {
        Symbol* sym = find_symbol(symbol_table, op->label);
        uint32_t value = sym ? sym->address : 0;
        if (!sym) fprintf(stderr, "WARN: Undefined symbol '%s' in second pass.\n", op->label);

        // A label can be an immediate value, an absolute address, or a displacement
        if (op->mode == IMMEDIATE) op->value = value;
        else if (op->mode == PC_RELATIVE_DISPLACEMENT || op->mode == PC_RELATIVE_INDEX_8_BIT) {
            op->base_displacement = value - (current_pc + 2);
        } else {
            op->value = value; // For absolute modes
        }
    }

    switch (op->mode) {
        case IMMEDIATE:
            if (size_suffix == 'L' || op->value > 0xFFFF) { mem_write_long(*address, op->value); *address += 4; }
            else { mem_write_word(*address, op->value); *address += 2; }
            break;
        case ABSOLUTE_SHORT:
            mem_write_word(*address, op->value); *address += 2;
            break;
        case ABSOLUTE_LONG:
            mem_write_long(*address, op->value); *address += 4;
            break;
        case ARI_DISPLACEMENT:
        case PC_RELATIVE_DISPLACEMENT:
            mem_write_word(*address, op->base_displacement); *address += 2;
            break;
        case ARI_INDEX_8_BIT_DISP:
        case PC_RELATIVE_INDEX_8_BIT:
        {
            uint16_t ext = 0;
            ext |= (op->index_is_an ? 1 : 0) << 15;
            ext |= (op->index_reg_num & 7) << 12;
            ext |= (op->index_size == 'L' ? 1 : 0) << 11;
            ext |= ((uint8_t)op->base_displacement);
            mem_write_word(*address, ext); *address += 2;
            break;
        }

        // --- 68020+ Full Format Modes ---
        case ARI_INDEX_BASE_DISP:
        case PC_INDEX_BASE_DISP:
        case MEMORY_INDIRECT_POST_INDEXED:
        case MEMORY_INDIRECT_PRE_INDEXED:
        case PC_MEM_INDIRECT_POST_INDEXED:
        case PC_MEM_INDIRECT_PRE_INDEXED:
        {
            // Capture the address of the extension word *before* writing it.
            uint32_t extension_word_address = *address;
            
            uint16_t ext = build_full_format_extension(op);
            mem_write_word(*address, ext); *address += 2;

            if (op->is_pc_relative_label) {
                Symbol* sym = find_symbol(symbol_table, op->label);
                uint32_t target_addr = sym ? sym->address : 0;
                // The displacement is relative to the extension word's address.
                op->base_displacement = target_addr - extension_word_address;
            }

            if (op->base_disp_size == 2) { mem_write_word(*address, op->base_displacement); *address += 2; }
            if (op->base_disp_size == 4) { mem_write_long(*address, op->base_displacement); *address += 4; }
            if (op->outer_disp_size == 2) { mem_write_word(*address, op->outer_displacement); *address += 2; }
            if (op->outer_disp_size == 4) { mem_write_long(*address, op->outer_displacement); *address += 4; }
            break;
        }

        default: break; // No extension words needed
    }
     if (op->label) { free(op->label); op->label = NULL; }
}


// --- Main Assembler Passes (First Pass is now simplified) ---

void perform_first_pass(FILE* f, uint32_t* start_address) {
    char* line;
    uint32_t current_address = *start_address;
    int symbol_count = 0;
    bool org_seen = false;

    while ((line = read_line_dynamically(f))) {
        char* original_line = line;
        char* comment = strchr(original_line, ';'); if (comment) *comment = '\0';
        char* trimmed_line = trim(original_line);
        if (strlen(trimmed_line) == 0 || trimmed_line[0] == '*') { free(original_line); continue; }

        char* instruction_part = trimmed_line;
        char* colon = strchr(trimmed_line, ':');
        if (colon) {
            *colon = '\0';
            char* label = trim(trimmed_line);
            add_symbol(symbol_table, label, current_address);
            symbol_count++;
            instruction_part = trim(colon + 1);
        }

        if (strlen(instruction_part) > 0) {
            char temp_instruction_part[256];
            strcpy(temp_instruction_part, instruction_part);
            char* saveptr = NULL;
            char* opcode_str = strtok_r(temp_instruction_part, " \t", &saveptr);
            if (opcode_str) {
                if (strcasecmp(opcode_str, "ORG") == 0) {
                    char* operand_str = saveptr;
                    if (operand_str) {
                        uint32_t org_address = strtoul(trim(operand_str) + 1, NULL, 16);
                        if (!org_seen) { *start_address = org_address; org_seen = true; }
                        current_address = org_address;
                    }
                } else {
                    char* operands_str = saveptr;
                    // The new get_instruction_size does all the heavy lifting
                    current_address += get_instruction_size(opcode_str, operands_str);
                }
            }
        }
        free(original_line);
    }
    printf("INFO: First pass complete. Found %d symbols.\n", symbol_count);
}


void perform_second_pass(FILE* f, uint32_t start_address) {
    char* line;
    uint32_t current_address = start_address;
    int line_number = 0;
    while ((line = read_line_dynamically(f))) {
        line_number++;
        char* original_line = line;
        char* comment = strchr(line, ';'); if (comment) *comment = '\0';
        char* instruction_part = trim(line);
        char* colon = strchr(instruction_part, ':'); if (colon) instruction_part = trim(colon + 1);
        if (strlen(instruction_part) == 0 || instruction_part[0] == '*') { free(original_line); continue; }

        disassembler_add_mapping(current_address, line_number, instruction_part);
        
        char temp_instruction_part[256];
        strcpy(temp_instruction_part, instruction_part);
        char* saveptr = NULL;
        char* opcode_str = strtok_r(temp_instruction_part, " \t", &saveptr);
        if (!opcode_str) { free(original_line); continue; }
        
        uint32_t instruction_start_address = current_address;

        if (strcasecmp(opcode_str, "ORG") == 0) {
            char* operand_str = saveptr;
            if (operand_str) current_address = strtoul(trim(operand_str) + 1, NULL, 16);
            free(original_line); continue;
        }

        char base_mnemonic[10]; char size_suffix;
        parse_instruction_mnemonic(opcode_str, base_mnemonic, &size_suffix);
        char* operands_str = saveptr;
        
        char temp_src_str[256];
        char temp_dest_str[256];
        char* src_str = NULL;
        char* dest_str = NULL;

        if (operands_str) {
            char* comma = strchr(operands_str, ',');
            if (comma) {
                size_t len = comma - operands_str;
                strncpy(temp_src_str, operands_str, len);
                temp_src_str[len] = '\0';
                strcpy(temp_dest_str, comma + 1);
                src_str = temp_src_str;
                dest_str = temp_dest_str;
            } else {
                strcpy(temp_src_str, operands_str);
                src_str = temp_src_str;
            }
        }
        
        // --- Instruction Encoding ---
        if (strcasecmp(base_mnemonic, "MOVE") == 0 || strcasecmp(base_mnemonic, "MOVEA") == 0) {
            Operand src_op = {0}, dest_op = {0};
            bool src_ok = src_str ? parse_operand(trim(src_str), &src_op) == 0 : false;
            bool dest_ok = dest_str ? parse_operand(trim(dest_str), &dest_op) == 0 : false;

            if (src_ok && dest_ok) {
                // Manually run the size calculation again to populate the disp_size fields
                // This is needed because the operand from the first pass is not saved.
                get_operand_extension_size(&src_op);
                get_operand_extension_size(&dest_op);

                uint16_t size_bits = (size_suffix == 'B') ? 1 : (size_suffix == 'L') ? 2 : 3;
                uint16_t dest_ea_field = encode_ea(&dest_op);
                uint16_t src_ea_field = encode_ea(&src_op);
                uint16_t machine_code = (size_bits << 12) | ((dest_ea_field & 7) << 9) | ((dest_ea_field >> 3) << 6) | src_ea_field;
                mem_write_word(current_address, machine_code);
                
                uint32_t addr = current_address + 2;
                write_operand_extensions(&addr, &src_op, size_suffix, instruction_start_address);
                write_operand_extensions(&addr, &dest_op, size_suffix, instruction_start_address);

                if (src_op.label) free(src_op.label);
                if (dest_op.label) free(dest_op.label);

            } else { fprintf(stderr, "L%d: Error: Invalid operands for MOVE\n", line_number); }
        }
        // ... (other instruction handlers like ADD, SUB, etc. would go here, following the same pattern)
        else if (strcasecmp(base_mnemonic, "DC") == 0) {
            uint32_t value = strtoul(trim(operands_str) + 1, NULL, 16); // Simple parsing for now
            if (size_suffix == 'B') {
                mem_write_byte(current_address, value);
            } else if (size_suffix == 'W') {
                mem_write_word(current_address, value);
            } else { // '.L'
                mem_write_long(current_address, value);
            }
        }
        else if (strcasecmp(base_mnemonic, "RTS") == 0) { // existing RTS
            mem_write_word(current_address, 0x4E75);
        }
        else if (strcasecmp(base_mnemonic, "NOP") == 0) {
            mem_write_word(current_address, 0x4E71);
        }
        else {
             fprintf(stderr, "L%d: WARN: Assembler does not yet support instruction '%s'\n", line_number, base_mnemonic);
        }
        
        current_address += get_instruction_size(opcode_str, operands_str);
        free(original_line);
    }
}


int load_file(const char* filename, uint32_t* start_address) {
    symbol_table = create_symbol_table(HASH_TABLE_SIZE);
    if (!symbol_table) return -1;
    FILE* f = fopen(filename, "r");
    if (!f) { perror("Failed to open assembly file"); destroy_symbol_table(symbol_table); return -1; }
    
    printf("INFO: Starting first pass...\n");
    perform_first_pass(f, start_address);
    rewind(f);
    
    printf("INFO: Starting second pass...\n");
    perform_second_pass(f, start_address);
    fclose(f);
    
    destroy_symbol_table(symbol_table);
    symbol_table = NULL;
    return 0;
}